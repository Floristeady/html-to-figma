<html>
<head>
  <title>HTML to Figma</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #FFFFFF;
      color: #1A1A1A;
      padding: 16px;
      line-height: 1.4;
      min-height: auto;
      display: flex;
      flex-direction: column;
    }

    .header {
      text-align: left;
      margin-bottom: 12px;
    }

    .subtitle {
      font-size: 14px;
      color: #1A1A1A;
      opacity: 0.7;
    }

    /* Tab Styles */
    .tab-container {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .tab {
      flex: 1;
      padding: 10px 16px;
      background: #F8F8F8;
      border: 2px solid #E6E6E6;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: #1A1A1A;
      opacity: 0.7;
      transition: all 0.2s ease;
      text-align: center;
    }

    .tab.active {
      background: #FFFFFF;
      border-color: #9747FF;
      opacity: 1;
    }

    .tab:hover {
      opacity: 0.9;
    }

    /* Tab Content */
    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* MCP Tab Styles */
    .mcp-description {
      font-size: 14px;
      color: #1A1A1A;
      opacity: 0.7;
      margin-bottom: 20px;
      text-align: left;
    }

    .switch-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding: 12px;
      background: #F8F8F8;
      border-radius: 6px;
    }

    .switch-label {
      font-size: 14px;
      font-weight: 500;
      color: #1A1A1A;
    }

    /* Toggle Switch */
    .switch {
      position: relative;
      display: inline-block;
      width: 48px;
      height: 24px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 24px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #9747FF;
    }

    input:checked + .slider:before {
      transform: translateX(24px);
    }

        /* Legacy Status Messages - Hidden to avoid conflicts */
    .status-messages {
      display: none !important;
    }

    /* Paste HTML Tab Styles */
    .input-container {
      margin-bottom: 12px;
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .textarea {
      width: 100%;
      flex: 1;
      min-height: 150px;
      padding: 12px;
      border: 1px solid #E6E6E6;
      border-radius: 6px;
      font-size: 12px;
      font-family: 'Monaco', 'Menlo', monospace;
      color: #1A1A1A;
      resize: none;
      outline: none;
      transition: border-color 0.2s ease;
      overflow-y: auto;
      margin-bottom: 4px;
    }

    .textarea:focus {
      border-color: #9747FF;
    }

    .textarea::placeholder {
      color: #1A1A1A;
      opacity: 0.4;
      font-size: 14px;
      font-weight: 500;
    }

    .button {
      width: 100%;
      height: 36px;
      background: #9747FF;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .button:hover {
      background: #8232FF;
    }

    .button:active {
      background: #7029E6;
    }

    .test-button {
      background: #6B7280;
      margin-top: auto;
      height: 32px;
      font-size: 13px;
    }

    .test-button:hover {
      background: #4B5563;
    }

    .description-text {
      font-size: 14px;
      color: #1A1A1A;
      opacity: 0.7;
      margin-bottom: 12px;
      text-align: left;
    }

    .description-text small {
      display: block;
      margin-top: 8px;
      color: #6c757d;
      font-size: 12px;
      line-height: 1.4;
      opacity: 0.8;
    }

    /* MCP CONFIG PANEL STYLES */
    .config-panel {
      margin-top: 12px;
      padding: 12px;
      background: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
    }

    .config-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
    }

    .config-tab {
      flex: 1;
      padding: 6px 10px;
      background: #e9ecef;
      border: none;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      color: #666;
      transition: all 0.2s;
    }

    .config-tab.active {
      background: #9747FF;
      color: white;
    }

    .config-tab:hover:not(.active) {
      background: #dee2e6;
    }

    .config-content {
      display: none;
    }

    .config-content.active {
      display: block;
    }

    .config-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 12px;
      color: #666;
    }

    .config-code {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 10px;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 10px;
      line-height: 1.4;
      overflow-x: auto;
      white-space: pre;
      margin: 0;
    }

    .config-note {
      margin-top: 8px;
      font-size: 11px;
      color: #888;
    }

    .config-note code {
      background: #e9ecef;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 10px;
    }

    .copy-btn {
      background: #9747FF;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .copy-btn:hover {
      background: #8232FF;
    }

    .copy-btn.copied {
      background: #22c55e;
    }

    /* CONNECTION STATUS STYLES - Minimalist */
    .connection-status {
      margin: 12px 0;
      padding: 12px 0;
      border-top: 1px solid #E6E6E6;
      border-bottom: 1px solid #E6E6E6;
    }

    .status-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
    }

    .status-icon {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 10px;
      background: #ccc;
      flex-shrink: 0;
    }

    .status-icon.connected {
      background: #22c55e;
    }

    .status-icon.error {
      background: #ef4444;
    }

    .status-icon.warning {
      background: #f59e0b;
    }

    .status-icon.inactive {
      background: #9ca3af;
    }

    .status-text {
      font-weight: 400;
      font-size: 13px;
      color: #666;
    }

    .info-row {
      margin-top: 8px;
    }

    .status-detail {
      font-size: 11px;
      color: #999;
    }

    /* ACTION BUTTONS */
    .action-buttons {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .button.secondary {
      background: transparent;
      color: #888;
      font-size: 12px;
      padding: 6px 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      width: auto;
      height: auto;
    }

    .button.secondary:hover {
      border-color: #999;
      color: #666;
    }

    .button.tertiary {
      background: transparent;
      color: #6c757d;
      border: 1px solid #6c757d;
      font-size: 12px;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      width: auto;
      height: auto;
    }

    .button.tertiary:hover {
      background: #6c757d;
      color: white;
    }


    /* Minimize Button - inline with action buttons */
    .minimize-btn {
      width: 28px;
      height: 28px;
      border: 1px solid #ccc;
      background: transparent;
      cursor: pointer;
      border-radius: 4px;
      display: grid;
      place-items: center;
      font-size: 16px;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      color: #888;
      margin-left: auto;
      transition: all 0.2s;
      padding-top: 3px;
      box-sizing: border-box;
    }

    .minimize-btn:hover {
      border-color: #999;
      color: #666;
    }

    /* Minimized state */
    .minimized-bar {
      display: none;
      padding: 8px 12px;
      background: #FFFFFF;
      align-items: center;
      gap: 10px;
      height: 36px;
    }

    .minimized-bar .minimize-btn {
      margin-left: auto;
      transform: rotate(180deg);
      padding-top: 0;
      padding-bottom: 3px;
    }

    .minimized-bar .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #dc3545;
      flex-shrink: 0;
    }

    .minimized-bar .status-dot.connected {
      background: #28a745;
    }

    .minimized-bar .status-text {
      font-size: 12px;
      color: #666;
      white-space: nowrap;
    }

    body.minimized .minimized-bar {
      display: flex;
    }

    body.minimized .plugin-content {
      display: none;
    }

    body.minimized {
      padding: 0;
      height: auto;
      overflow: hidden;
    }

  </style>
</head>
<body>
  <!-- Minimized state bar (hidden by default) -->
  <div class="minimized-bar">
    <span class="status-dot" id="minimized-status-dot"></span>
    <span class="status-text" id="minimized-status-text">Disconnected</span>
    <button class="minimize-btn minimized-expand-btn" id="minimized-expand-btn" title="Expand">‚åÉ</button>
  </div>

  <!-- Main Content -->
  <div class="plugin-content" id="plugin-content">

    <!-- Tabs -->
    <div class="tab-container">
    <button class="tab active" data-tab="mcp">MCP Bridge</button>
    <button class="tab" data-tab="paste">Paste HTML</button>
  </div>

  <!-- MCP Bridge Tab Content -->
  <div class="tab-content active" id="mcp-tab">
    <div class="description-text">
      Connect with AI tools via MCP to send HTML directly to Figma.
    </div>

    <!-- MAIN CONTROL -->
    <div class="switch-container">
      <span class="switch-label">Enable MCP Bridge</span>
      <label class="switch">
        <input type="checkbox" id="mcp-switch">
        <span class="slider"></span>
      </label>
    </div>

    <!-- CONNECTION STATUS -->
    <div class="connection-status" id="connection-status">
      <div class="status-row">
        <span class="status-icon inactive" id="sse-indicator"></span>
        <span class="status-text" id="sse-status-text">SSE Disconnected</span>
      </div>
      <div class="status-row">
        <span class="status-icon inactive" id="mcp-indicator"></span>
        <span class="status-text" id="mcp-status-text">MCP Inactive</span>
      </div>
      <div class="status-row info-row">
        <span class="status-detail" id="connection-details">Ready to connect</span>
      </div>
    </div>

    <!-- ACTIONS -->
    <div class="action-buttons">
      <button id="mcp-config-btn" class="button secondary">MCP Config</button>
      <button id="test-broadcast-btn" class="button secondary">Test Connection</button>
      <button class="minimize-btn" id="minimize-btn" title="Minimize">‚åÉ</button>
    </div>

    <!-- MCP CONFIG PANEL (Hidden by default) -->
    <div class="config-panel" id="mcp-config-panel" style="display: none;">
      <!-- Config Tabs -->
      <div class="config-tabs">
        <button class="config-tab active" data-target="claude-code-config">Claude Code</button>
        <button class="config-tab" data-target="cursor-config">Cursor / Desktop</button>
      </div>

      <!-- Claude Code Config -->
      <div class="config-content active" id="claude-code-config">
        <div class="config-header">
          <span>Run this command:</span>
          <button class="copy-btn" id="copy-claude-cmd">Copy</button>
        </div>
        <pre class="config-code" id="claude-code-cmd">claude mcp add figma-html-bridge -s local \
  -e FIGMA_SERVER_URL=http://localhost:3003 \
  -e FIGMA_SESSION_ID=loading... \
  -e API_KEY=dev-key \
  -- node mcp-server.js</pre>
        <div class="config-note">
          Run in terminal, then <code>/exit</code> and restart Claude Code
        </div>
      </div>

      <!-- Cursor / Claude Desktop Config -->
      <div class="config-content" id="cursor-config">
        <div class="config-header">
          <span>Add to config file:</span>
          <button class="copy-btn" id="copy-cursor-config">Copy</button>
        </div>
        <pre class="config-code" id="cursor-config-code">{
  "html-to-figma": {
    "command": "npx",
    "args": ["-y", "github:Floristeady/html-to-figma"],
    "env": {
      "FIGMA_SERVER_URL": "http://localhost:3003",
      "FIGMA_SESSION_ID": "loading...",
      "API_KEY": "dev-key"
    }
  }
}</pre>
        <div class="config-note">
          Paste in: <code>~/.cursor/mcp.json</code>
        </div>
      </div>
    </div>
  </div>

  <!-- Paste HTML Tab Content -->
  <div class="tab-content" id="paste-tab">
    <div class="description-text">Paste your HTML code and convert it to Figma elements</div>

    <div class="input-container">
      <textarea
        id="html-input"
        class="textarea"
        placeholder="Paste your HTML here..."
      ></textarea>
    </div>

    <button id="send-btn" class="button">Convert to Figma</button>
  </div>

  </div><!-- End plugin-content -->

<script>
// Global variable to control detailed logging
var detailedLogsEnabled = true;

// Global session ID (received from plugin)
var currentSessionId = null;

// Copy to clipboard function (works in Figma plugin context)
function copyToClipboard(text) {
  var textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.style.position = 'fixed';
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.select();
  try {
    document.execCommand('copy');
    return true;
  } catch (err) {
    console.error('Copy failed:', err);
    return false;
  } finally {
    document.body.removeChild(textarea);
  }
}

// MCP Config - Auto-detect server (localhost first, then production)
var LOCAL_SERVER = 'http://localhost:3003';
var PROD_SERVER = 'https://html-to-figma.onrender.com';
var LOCAL_API_KEY = 'dev-key';
var PROD_API_KEY = 'figma-team-2026';

// Will be set after detection
var MCP_SERVER_URL = null;
var MCP_API_KEY = null;
var serverDetected = false;

var MCP_GITHUB_REPO = 'github:Floristeady/html-to-figma';

// Auto-detect which server to use
function detectServer(callback) {
  if (serverDetected) {
    callback();
    return;
  }

  debugLog('[SERVER] Detecting server...');
  updateConnectionDetails('Detecting server...');

  // Try localhost first with a short timeout
  var timeoutId = setTimeout(function() {
    // Timeout - localhost not responding, use production
    debugLog('[SERVER] Localhost timeout, using production');
    MCP_SERVER_URL = PROD_SERVER;
    MCP_API_KEY = PROD_API_KEY;
    serverDetected = true;
    updateConnectionDetails('Using production server');
    callback();
  }, 1500);

  fetch(LOCAL_SERVER + '/mcp-status', { method: 'GET' })
    .then(function(response) {
      if (response.ok) {
        clearTimeout(timeoutId);
        debugLog('[SERVER] Localhost detected, using local server');
        MCP_SERVER_URL = LOCAL_SERVER;
        MCP_API_KEY = LOCAL_API_KEY;
        serverDetected = true;
        updateConnectionDetails('Using local server');
        callback();
      } else {
        throw new Error('Not OK');
      }
    })
    .catch(function(error) {
      clearTimeout(timeoutId);
      if (!serverDetected) {
        debugLog('[SERVER] Localhost not available, using production');
        MCP_SERVER_URL = PROD_SERVER;
        MCP_API_KEY = PROD_API_KEY;
        serverDetected = true;
        updateConnectionDetails('Using production server');
        callback();
      }
    });
}

// Generate Claude Code command (always show production values for user to copy)
function generateClaudeCodeCmd() {
  var sessionId = currentSessionId || 'YOUR_SESSION_ID';
  return 'claude mcp add figma-html-bridge -s local \\\n' +
    '  -e FIGMA_SERVER_URL=' + PROD_SERVER + ' \\\n' +
    '  -e FIGMA_SESSION_ID=' + sessionId + ' \\\n' +
    '  -e API_KEY=' + PROD_API_KEY + ' \\\n' +
    '  -- npx -y ' + MCP_GITHUB_REPO;
}

// Generate Cursor/Desktop config JSON (always show production values for user to copy)
function generateCursorConfig() {
  return JSON.stringify({
    "figma-html-bridge": {
      "command": "npx",
      "args": ["-y", MCP_GITHUB_REPO],
      "env": {
        "FIGMA_SERVER_URL": PROD_SERVER,
        "FIGMA_SESSION_ID": currentSessionId || "YOUR_SESSION_ID",
        "API_KEY": PROD_API_KEY
      }
    }
  }, null, 2);
}

// Update config display when session ID changes
function updateConfigDisplay() {
  var claudeCmd = document.getElementById('claude-code-cmd');
  var cursorConfig = document.getElementById('cursor-config-code');
  if (claudeCmd) {
    claudeCmd.textContent = generateClaudeCodeCmd();
  }
  if (cursorConfig) {
    cursorConfig.textContent = generateCursorConfig();
  }
}

// Config tabs switching
document.querySelectorAll('.config-tab').forEach(function(tab) {
  tab.addEventListener('click', function() {
    var targetId = this.getAttribute('data-target');

    // Update tabs
    document.querySelectorAll('.config-tab').forEach(function(t) {
      t.classList.remove('active');
    });
    this.classList.add('active');

    // Update content
    document.querySelectorAll('.config-content').forEach(function(c) {
      c.classList.remove('active');
    });
    document.getElementById(targetId).classList.add('active');
  });
});

// MCP Config panel toggle
document.getElementById('mcp-config-btn').addEventListener('click', function() {
  var panel = document.getElementById('mcp-config-panel');
  if (panel.style.display === 'none') {
    panel.style.display = 'block';
    this.textContent = 'Hide Config';
    updateConfigDisplay();
  } else {
    panel.style.display = 'none';
    this.textContent = 'MCP Config';
  }
});

// Copy Claude Code command
document.getElementById('copy-claude-cmd').addEventListener('click', function() {
  if (copyToClipboard(generateClaudeCodeCmd())) {
    var btn = this;
    btn.textContent = 'Copied!';
    btn.classList.add('copied');
    setTimeout(function() {
      btn.textContent = 'Copy';
      btn.classList.remove('copied');
    }, 2000);
  }
});

// Copy Cursor config
document.getElementById('copy-cursor-config').addEventListener('click', function() {
  if (copyToClipboard(generateCursorConfig())) {
    var btn = this;
    btn.textContent = 'Copied!';
    btn.classList.add('copied');
    setTimeout(function() {
      btn.textContent = 'Copy';
      btn.classList.remove('copied');
    }, 2000);
  }
});

// Function for conditional debugging logs
function debugLog(...args) {
  if (detailedLogsEnabled) {
    console.log(...args);
  }
}

// Essential CSS properties that Figma doesn't support
var UNSUPPORTED_CSS_PROPERTIES = [
  'animation', 'animation-name', 'animation-duration', 'animation-timing-function',
  'animation-delay', 'animation-iteration-count', 'animation-direction',
  'animation-fill-mode', 'animation-play-state', 'transition', 'transition-property',
  'transition-duration', 'transition-timing-function', 'transition-delay'
  // Note: 'transform' removed - now supported (rotate, scale, translate)
];

// Supported content for pseudo-elements
var SUPPORTED_CONTENT = {
  '"üìö"': 'üìö', '"üí¨"': 'üí¨', '"üèõÔ∏è"': 'üèõÔ∏è', '"‚öΩ"': '‚öΩ', '"üè†"': 'üè†', '"üë•"': 'üë•',
  '"üìà"': 'üìà', '"üìñ"': 'üìñ', '"‚òÖ"': '‚òÖ', '"‚Ä¢"': '‚Ä¢', '"‚Üí"': '‚Üí', '"‚Üê"': '‚Üê',
  '"‚ñº"': '‚ñº', '"‚ñ≤"': '‚ñ≤', '"‚úì"': '‚úì', '"‚úó"': '‚úó', '"üí°"': 'üí°', '"üéØ"': 'üéØ',
  '"üìÖ"': 'üìÖ', '"üïê"': 'üïê', '"‚è±Ô∏è"': '‚è±Ô∏è', '"üìä"': 'üìä', '"üìù"': 'üìù',
  '"üèüÔ∏è"': 'üèüÔ∏è', '"üìç"': 'üìç', '"üè¢"': 'üè¢', '""': ''
};

// Tab functionality
document.querySelectorAll('.tab').forEach(function(tab) {
  tab.addEventListener('click', function() {
    var targetTab = this.getAttribute('data-tab');

    // Remove active class from all tabs and contents
    document.querySelectorAll('.tab').forEach(function(t) {
      t.classList.remove('active');
    });
    document.querySelectorAll('.tab-content').forEach(function(content) {
      content.classList.remove('active');
    });

    // Add active class to clicked tab and corresponding content
    this.classList.add('active');
    document.getElementById(targetTab + '-tab').classList.add('active');
  });
});

// MCP Switch functionality
var mcpMonitoring = false;
document.getElementById('mcp-switch').addEventListener('change', function() {
  mcpMonitoring = this.checked;

  if (mcpMonitoring) {
    updateConnectionStatus('connecting');
    updateSSEStatus('SSE Connecting...', 'connecting');
    updateMCPStatus('MCP Starting', 'connecting');
    updateConnectionDetails('Establishing connection...');

    // Start SSE connection
    parent.postMessage({
      pluginMessage: {
        type: 'start-sse'
      }
    }, '*');

    // Start MCP monitoring
    parent.postMessage({
      pluginMessage: {
        type: 'start-mcp-monitoring'
      }
    }, '*');
  } else {
    updateConnectionStatus('disconnected');
    updateSSEStatus('SSE Disconnected', 'disconnected');
    updateMCPStatus('MCP Inactive', 'disconnected');
    updateConnectionDetails('Ready to connect');

    // Stop SSE connection
    parent.postMessage({
      pluginMessage: {
        type: 'stop-sse'
      }
    }, '*');

    // Stop MCP monitoring
    parent.postMessage({
      pluginMessage: {
        type: 'stop-mcp-monitoring'
      }
    }, '*');
  }
});

// Test connection button
document.getElementById('test-broadcast-btn').addEventListener('click', function() {
  updateConnectionDetails('Testing connection...');

  // Send test request via SSE
  parent.postMessage({
    pluginMessage: {
      type: 'test-broadcast'
    }
  }, '*');

  setTimeout(function() {
    updateConnectionDetails('Connection test sent');
  }, 1000);
});

// Minimize/Expand functionality
var isMinimized = false;
var isConnected = false;

function updateMinimizedStatus() {
  var dot = document.getElementById('minimized-status-dot');
  var text = document.getElementById('minimized-status-text');
  if (dot && text) {
    if (isConnected) {
      dot.classList.add('connected');
      text.textContent = 'Connected';
    } else {
      dot.classList.remove('connected');
      text.textContent = 'Disconnected';
    }
  }
}

function toggleMinimize() {
  isMinimized = !isMinimized;
  var btn = document.getElementById('minimize-btn');

  if (isMinimized) {
    document.body.classList.add('minimized');
    btn.textContent = '‚åÑ';
    btn.title = 'Expand';
    updateMinimizedStatus();
    // Send message to resize plugin window
    parent.postMessage({
      pluginMessage: {
        type: 'resize-plugin',
        minimized: true
      }
    }, '*');
  } else {
    document.body.classList.remove('minimized');
    btn.textContent = '‚åÉ';
    btn.title = 'Minimize';
    // Send message to restore plugin window
    parent.postMessage({
      pluginMessage: {
        type: 'resize-plugin',
        minimized: false
      }
    }, '*');
  }
}

document.getElementById('minimize-btn').addEventListener('click', toggleMinimize);
document.getElementById('minimized-expand-btn').addEventListener('click', toggleMinimize);

// Helper functions for new UI elements
function updateConnectionStatus(status) {
  var statusContainer = document.getElementById('connection-status');
  statusContainer.className = 'connection-status ' + status;
}

function updateSSEStatus(text, status) {
  var indicator = document.getElementById('sse-indicator');
  var statusText = document.getElementById('sse-status-text');

  // Update global connection state
  isConnected = (status === 'connected');
  updateMinimizedStatus();

  if (statusText) {
    statusText.textContent = text;
  }

  if (indicator) {
    indicator.className = 'status-icon';
    switch(status) {
      case 'connected':
        indicator.classList.add('connected');
        break;
      case 'connecting':
        indicator.classList.add('warning');
        break;
      case 'error':
        indicator.classList.add('error');
        break;
      default:
        indicator.classList.add('inactive');
    }
  }
}

function updateMCPStatus(text, status) {
  var indicator = document.getElementById('mcp-indicator');
  var statusText = document.getElementById('mcp-status-text');

  if (statusText) {
    statusText.textContent = text;
  }

  if (indicator) {
    indicator.className = 'status-icon';
    switch(status) {
      case 'connected':
      case 'success':
        indicator.classList.add('connected');
        break;
      case 'connecting':
        indicator.classList.add('warning');
        break;
      case 'error':
        indicator.classList.add('error');
        break;
      default:
        indicator.classList.add('inactive');
    }
  }
}

function updateConnectionDetails(text) {
  var details = document.getElementById('connection-details');
  if (details) {
    details.textContent = text;
  }
}

// CSS filtering and parsing functions
function filterUnsupportedCSS(styles) {
  var filteredStyles = {};
  for (var prop in styles) {
    if (styles.hasOwnProperty(prop)) {
      if (prop === 'content') {
        var contentValue = styles[prop];
        if (SUPPORTED_CONTENT.hasOwnProperty(contentValue)) {
          filteredStyles[prop] = styles[prop];
        }
      } else if (UNSUPPORTED_CSS_PROPERTIES.indexOf(prop) === -1) {
        filteredStyles[prop] = styles[prop];
      }
    }
  }
  return filteredStyles;
}

function parseInlineStyles(styleStr, trackImportant) {
  var styles = {};
  var importantStyles = {}; // Track !important properties separately
  if (!styleStr) return trackImportant ? { styles: styles, important: importantStyles } : styles;
  var declarations = styleStr.split(';');
  for (var i = 0; i < declarations.length; i++) {
    var decl = declarations[i].trim();
    if (decl) {
      var colonIdx = decl.indexOf(':');
      if (colonIdx > 0) {
        // Normalize property names to lowercase for consistency
        var prop = decl.substring(0, colonIdx).trim().toLowerCase();
        var val = decl.substring(colonIdx + 1).trim();

        // Check for and strip !important, tracking it separately
        var isImportant = val.indexOf('!important') !== -1;
        if (isImportant) {
          val = val.replace(/\s*!important\s*/gi, '').trim();
        }

        if (isImportant) {
          importantStyles[prop] = val;
        } else {
          styles[prop] = val;
        }

        // Parse 'font' shorthand to extract font-size
        // font: [style] [variant] [weight] [stretch] size[/line-height] family
        if (prop === 'font' && val) {
          var fontMatch = val.match(/(?:^|\s)(\d+(?:\.\d+)?(?:px|rem|em|pt|vh|vw|%)?)\s*(?:\/\s*[\d.]+(?:px|rem|em|%|[a-z]+)?)?\s+/i);
          if (fontMatch && !styles['font-size'] && !importantStyles['font-size']) {
            if (isImportant) {
              importantStyles['font-size'] = fontMatch[1];
            } else {
              styles['font-size'] = fontMatch[1];
            }
          }
        }
      }
    }
  }

  if (trackImportant) {
    return {
      styles: filterUnsupportedCSS(styles),
      important: filterUnsupportedCSS(importantStyles)
    };
  }

  // For CSS rules storage: preserve !important marker in values
  // This allows getElementStyles to detect !important later
  var result = filterUnsupportedCSS(styles);
  var importantFiltered = filterUnsupportedCSS(importantStyles);
  for (var key in importantFiltered) {
    if (importantFiltered.hasOwnProperty(key)) {
      // Re-add !important marker so it can be detected in getElementStyles
      result[key] = importantFiltered[key] + ' !important';
    }
  }
  return result;
}

// Funci√≥n para verificar si un selector CSS es problem√°tico
function isUnsupportedSelector(selector) {
  // Omitir @keyframes, @media, etc.
  if (selector.charAt(0) === '@') {
    return true;
  }

  // Omitir pseudo-selectores problem√°ticos (excepto ::before/::after que ahora soportamos)
  if (selector.includes(':hover') ||
      selector.includes(':active') ||
      selector.includes(':focus') ||
      selector.includes(':nth-child') ||
      selector.includes(':first-child') ||
      selector.includes(':last-child')) {
    return true;
  }

  // Permitir ::before y ::after (ahora los soportamos parcialmente)
  return false;
}

// Funci√≥n mejorada para manejar selectores CSS complejos
function parseComplexSelector(selector) {
  // Limpiar espacios extra (sin regex problem√°tico)
  selector = selector.split(/[ ]+/).join(' ').trim();

  // Manejar m√∫ltiples selectores separados por coma
  if (selector.indexOf(',') !== -1) {
    return selector.split(',').map(function(s) { return s.trim(); });
  }

  return [selector];
}

// Funci√≥n mejorada para validar selectores CSS
function isValidCSSSelector(selector) {
  // Validaci√≥n simplificada sin regex complejos
  if (!selector || selector.length === 0) return false;

  // Selector de elemento simple (h1, div, span)
  if (/^[a-zA-Z][a-zA-Z0-9-]*$/.test(selector)) return true;

  // Selector de clase simple (.class)
  if (selector.charAt(0) === '.' && selector.indexOf(' ') === -1) return true;

  // Selector de ID (#id)
  if (selector.charAt(0) === '#') return true;

  // Selectores anidados (.parent .child, div .class, etc.)
  if (selector.indexOf(' ') !== -1) return true;

  // Pseudoelementos (::before, ::after)
  if (selector.indexOf('::') !== -1) return true;

  return false;
}

function extractCSS(htmlStr) {
  var cssRules = {};
  var cssVariables = {}; // FIXED: Store CSS variables
  var allCssText = '';

  // Soportar m√∫ltiples style tags
  var searchStr = htmlStr;
  var startTag = '<style';
  var endTag = '</style>';

  while (true) {
    var styleStart = searchStr.indexOf(startTag);
    if (styleStart === -1) break;

    var contentStart = searchStr.indexOf('>', styleStart);
    if (contentStart === -1) break;
    contentStart += 1;

    var styleEnd = searchStr.indexOf(endTag, contentStart);
    if (styleEnd === -1) break;

    allCssText += searchStr.substring(contentStart, styleEnd) + ' ';
    searchStr = searchStr.substring(styleEnd + endTag.length);
  }

  if (!allCssText) return cssRules;

  // Remove CSS comments (simple approach sin regex problem√°tico)
  var cleanCss = '';
  var inComment = false;
  for (var ci = 0; ci < allCssText.length; ci++) {
    if (!inComment && allCssText[ci] === '/' && allCssText[ci+1] === '*') {
      inComment = true;
      ci++;
    } else if (inComment && allCssText[ci] === '*' && allCssText[ci+1] === '/') {
      inComment = false;
      ci++;
    } else if (!inComment) {
      cleanCss += allCssText[ci];
    }
  }
  allCssText = cleanCss;

  // FIXED: Extract CSS variables from :root
  var rootMatch = allCssText.match(/:root\s*\{([^}]+)\}/);
  if (rootMatch) {
    var rootDeclarations = rootMatch[1];
    var varPairs = rootDeclarations.split(';');
    for (var vi = 0; vi < varPairs.length; vi++) {
      var pair = varPairs[vi].trim();
      if (pair.indexOf('--') === 0) {
        var colonIdx = pair.indexOf(':');
        if (colonIdx > 0) {
          var varName = pair.substring(0, colonIdx).trim();
          var varValue = pair.substring(colonIdx + 1).trim();
          cssVariables[varName] = varValue;
        }
      }
    }
  }

  // FIXED: Function to resolve var() references
  function resolveVariables(value) {
    if (!value || typeof value !== 'string') return value;
    return value.replace(/var\(([^)]+)\)/g, function(match, varRef) {
      var parts = varRef.split(',');
      var varName = parts[0].trim();
      var fallback = parts[1] ? parts[1].trim() : null;
      return cssVariables[varName] || fallback || match;
    });
  }

  // FIXED: Remove @media, @keyframes, @supports blocks to prevent parsing issues
  // These have nested braces that confuse the simple split by '}'
  function removeAtRuleBlocks(css) {
    var result = '';
    var i = 0;
    while (i < css.length) {
      // Check for @ rules
      if (css[i] === '@' && (css.substring(i, i + 6) === '@media' ||
                             css.substring(i, i + 10) === '@keyframes' ||
                             css.substring(i, i + 9) === '@supports' ||
                             css.substring(i, i + 8) === '@charset' ||
                             css.substring(i, i + 7) === '@import')) {
        // Find the opening brace
        var braceStart = css.indexOf('{', i);
        if (braceStart === -1) {
          // No brace, skip to end of line
          var lineEnd = css.indexOf(';', i);
          i = lineEnd !== -1 ? lineEnd + 1 : css.length;
          continue;
        }
        // Count braces to find matching closing brace
        var braceCount = 1;
        var j = braceStart + 1;
        while (j < css.length && braceCount > 0) {
          if (css[j] === '{') braceCount++;
          else if (css[j] === '}') braceCount--;
          j++;
        }
        i = j; // Skip the entire @rule block
      } else {
        result += css[i];
        i++;
      }
    }
    return result;
  }

  allCssText = removeAtRuleBlocks(allCssText);

  var rules = allCssText.split('}');

  for (var i = 0; i < rules.length; i++) {
    var rule = rules[i].trim();
    if (rule) {
      var braceIdx = rule.indexOf('{');
      if (braceIdx > 0) {
        var selector = rule.substring(0, braceIdx).trim();
        var declarations = rule.substring(braceIdx + 1).trim();

        if (selector && declarations && !isUnsupportedSelector(selector)) {
          // Procesar selectores m√∫ltiples (separados por coma)
          var selectors = parseComplexSelector(selector);

          for (var j = 0; j < selectors.length; j++) {
            var singleSelector = selectors[j];

            if (isValidCSSSelector(singleSelector)) {
              // FIXED: Resolve CSS variables before parsing
              var resolvedDeclarations = resolveVariables(declarations);
              // Almacenar la regla CSS procesada
              cssRules[singleSelector] = Object.assign({}, cssRules[singleSelector] || {}, parseInlineStyles(resolvedDeclarations));

              // Tambi√©n manejar variaciones del selector
              if (singleSelector.includes(' ')) {
                // Para selectores anidados, tambi√©n guardar versi√≥n normalizada
                var normalizedSelector = singleSelector.replace(/\s+/g, ' ');
                if (normalizedSelector !== singleSelector) {
                  cssRules[normalizedSelector] = Object.assign({}, cssRules[normalizedSelector] || {}, parseInlineStyles(resolvedDeclarations));
                }
              }
            }
          }
        }
      }
    }
  }

  return cssRules;
}

// Detect root font-size from CSS (for rem unit conversion)
// Returns the font-size in pixels, defaults to 16 if not found
function detectRootFontSize(htmlStr) {
  var cssRules = extractCSS(htmlStr);
  var DEFAULT_REM_BASE = 16;

  // Check html selector first
  if (cssRules['html'] && cssRules['html']['font-size']) {
    var fontSize = cssRules['html']['font-size'];
    // Handle percentage: 62.5% = 10px, 100% = 16px
    if (fontSize.indexOf('%') !== -1) {
      var percent = parseFloat(fontSize);
      if (!isNaN(percent)) {
        return (percent / 100) * DEFAULT_REM_BASE;
      }
    }
    // Handle px value
    if (fontSize.indexOf('px') !== -1) {
      var px = parseFloat(fontSize);
      if (!isNaN(px)) {
        return px;
      }
    }
  }

  // Check :root selector
  if (cssRules[':root'] && cssRules[':root']['font-size']) {
    var fontSize = cssRules[':root']['font-size'];
    if (fontSize.indexOf('%') !== -1) {
      var percent = parseFloat(fontSize);
      if (!isNaN(percent)) {
        return (percent / 100) * DEFAULT_REM_BASE;
      }
    }
    if (fontSize.indexOf('px') !== -1) {
      var px = parseFloat(fontSize);
      if (!isNaN(px)) {
        return px;
      }
    }
  }

  return DEFAULT_REM_BASE;
}

// Viewport presets for design width detection (UI context)
var VIEWPORT_PRESETS_UI = {
  'mobile': 375,
  'tablet': 768,
  'desktop': 1440,
  'large': 1600,
  'wide': 1920
};

// Detect design width from HTML meta tags ONLY (UI context version)
// El an√°lisis completo de CSS y estructura se hace en code.ts con calculateContainerWidth()
function detectDesignWidthFromHTML(htmlStr) {
  // 1. Check for meta tag: <meta name="figma-width" content="375"> (flexible order)
  var widthMatch1 = htmlStr.match(/<meta[^>]+name=["']figma-width["'][^>]+content=["'](\d+)["'][^>]*>/i);
  var widthMatch2 = htmlStr.match(/<meta[^>]+content=["'](\d+)["'][^>]+name=["']figma-width["'][^>]*>/i);
  var widthMetaMatch = widthMatch1 || widthMatch2;
  if (widthMetaMatch) {
    var width = parseInt(widthMetaMatch[1], 10);
    if (!isNaN(width) && width > 0) {
      return width;
    }
  }

  // 2. Check for viewport preset: <meta name="figma-viewport" content="mobile"> (flexible order)
  var vpMatch1 = htmlStr.match(/<meta[^>]+name=["']figma-viewport["'][^>]+content=["'](\w+)["'][^>]*>/i);
  var vpMatch2 = htmlStr.match(/<meta[^>]+content=["'](\w+)["'][^>]+name=["']figma-viewport["'][^>]*>/i);
  var viewportMetaMatch = vpMatch1 || vpMatch2;
  if (viewportMetaMatch) {
    var preset = viewportMetaMatch[1].toLowerCase();
    if (VIEWPORT_PRESETS_UI[preset]) {
      return VIEWPORT_PRESETS_UI[preset];
    }
  }

  // 3. Check for HTML comment: <!-- figma-width: 1920 -->
  var commentMatch = htmlStr.match(/<!--\s*figma-width:\s*(\d+)\s*-->/i);
  if (commentMatch) {
    var width = parseInt(commentMatch[1], 10);
    if (!isNaN(width) && width > 0) {
      return width;
    }
  }

  // 4. UI solo detecta meta tags - el an√°lisis de CSS/estructura se hace en code.ts
  // Esto evita falsos positivos de elementos como .chapter-image-vertical: 160px

  // Solo retornamos null aqu√≠ - code.ts usar√° calculateContainerWidth()
  // para el an√°lisis completo de estructura y CSS
  return null;
}

// HTML parsing function - COMPLETE VERSION with CSS specificity support
function simpleParseHTML(htmlStr) {
  var parser = new DOMParser();
  var doc = parser.parseFromString(htmlStr, 'text/html');
  var body = doc.body || doc.documentElement;

  var cssRules = extractCSS(htmlStr);

  // Funci√≥n para extraer content de pseudoelementos
  function extractPseudoContent(element, cssRules) {
    var className = element.getAttribute('class');
    var tagName = element.tagName.toLowerCase();
    var beforeContent = '';
    var afterContent = '';

    if (className) {
      var classes = className.split(' ').filter(function(c) { return c.trim(); });

      // Buscar ::before content
      for (var i = 0; i < classes.length; i++) {
        var beforeSelector = '.' + classes[i] + '::before';
        if (cssRules[beforeSelector] && cssRules[beforeSelector].content) {
          var contentValue = cssRules[beforeSelector].content;
          if (SUPPORTED_CONTENT.hasOwnProperty(contentValue)) {
            beforeContent = SUPPORTED_CONTENT[contentValue];
            break;
          }
        }
      }

      // Buscar ::after content
      for (var i = 0; i < classes.length; i++) {
        var afterSelector = '.' + classes[i] + '::after';
        if (cssRules[afterSelector] && cssRules[afterSelector].content) {
          var contentValue = cssRules[afterSelector].content;
          if (SUPPORTED_CONTENT.hasOwnProperty(contentValue)) {
            afterContent = SUPPORTED_CONTENT[contentValue];
            break;
          }
        }
      }
    }

    // Tambi√©n buscar por elemento
    var beforeElementSelector = tagName + '::before';
    var afterElementSelector = tagName + '::after';

    if (cssRules[beforeElementSelector] && cssRules[beforeElementSelector].content && !beforeContent) {
      var contentValue = cssRules[beforeElementSelector].content;
      if (SUPPORTED_CONTENT.hasOwnProperty(contentValue)) {
        beforeContent = SUPPORTED_CONTENT[contentValue];
      }
    }

    if (cssRules[afterElementSelector] && cssRules[afterElementSelector].content && !afterContent) {
      var contentValue = cssRules[afterElementSelector].content;
      if (SUPPORTED_CONTENT.hasOwnProperty(contentValue)) {
        afterContent = SUPPORTED_CONTENT[contentValue];
      }
    }

    return { before: beforeContent, after: afterContent };
  }

  // Funci√≥n mejorada para obtener todos los selectores que aplican a un elemento
  function getAllMatchingSelectors(element) {
    var matchingSelectors = [];
    var className = element.getAttribute('class');
    var tagName = element.tagName.toLowerCase();
    var elementId = element.getAttribute('id');

    // Construir jerarqu√≠a de ancestors
    var ancestors = [];
    var currentElement = element.parentElement;
    while (currentElement && currentElement.tagName !== 'BODY' && currentElement.tagName !== 'HTML') {
      var ancestorClasses = currentElement.getAttribute('class');
      var ancestorTag = currentElement.tagName.toLowerCase();
      var ancestorId = currentElement.getAttribute('id');

      ancestors.push({
        classes: ancestorClasses ? ancestorClasses.split(' ').filter(function(c) { return c.trim(); }) : [],
        tag: ancestorTag,
        id: ancestorId
      });
      currentElement = currentElement.parentElement;
    }

    // Verificar todos los selectores CSS disponibles
    for (var selector in cssRules) {
      if (cssRules.hasOwnProperty(selector)) {
        // Skip pseudo-element selectors for main style matching
        if (selector.includes('::before') || selector.includes('::after')) {
          continue;
        }
        if (selectorMatches(selector, element, className, tagName, elementId, ancestors)) {
          matchingSelectors.push({
            selector: selector,
            specificity: calculateSpecificity(selector),
            styles: cssRules[selector]
          });
        }
      }
    }

    // Ordenar por especificidad (menor a mayor)
    matchingSelectors.sort(function(a, b) {
      return a.specificity - b.specificity;
    });

    return matchingSelectors;
  }

  // Funci√≥n para verificar si un selector CSS coincide con un elemento
  function selectorMatches(selector, element, className, tagName, elementId, ancestors) {
    // FIXED: Universal selector (*) matches all elements
    if (selector === '*') {
      return true;
    }

    // Selector de elemento simple
    if (selector === tagName) {
      return true;
    }

    // Selector de clase simple
    if (selector.charAt(0) === '.' && !selector.includes(' ') && className) {
      var selectorClass = selector.substring(1);
      // Handle combined classes like .class1.class2
      if (selectorClass.includes('.')) {
        return matchesCombinedClasses(selector, className);
      }
      var classes = className.split(' ').filter(function(c) { return c.trim(); });
      return classes.indexOf(selectorClass) !== -1;
    }

    // Selector de ID
    if (selector.charAt(0) === '#' && elementId) {
      return selector.substring(1) === elementId;
    }

    // Selectores anidados (descendant, child >, sibling +, ~)
    if (selector.includes(' ') || selector.includes('>') || selector.includes('+') || selector.includes('~')) {
      return matchesNestedSelector(selector, element, className, tagName, elementId, ancestors);
    }

    // Selectores m√∫ltiples con clases combinadas (.class1.class2)
    if (selector.includes('.') && !selector.includes(' ') && selector.indexOf('.') !== selector.lastIndexOf('.')) {
      return matchesCombinedClasses(selector, className);
    }

    return false;
  }

  // Funci√≥n para manejar selectores anidados (descendant, child >, sibling +~)
  function matchesNestedSelector(selector, element, className, tagName, elementId, ancestors) {
    // Parse selector into tokens with combinators
    // Combinators: ' ' (descendant), '>' (child), '+' (adjacent sibling), '~' (general sibling)
    var tokens = parseSelector(selector);

    if (tokens.length === 0) return false;

    // Last token must match current element
    var lastToken = tokens[tokens.length - 1];
    if (!selectorMatches(lastToken.selector, element, className, tagName, elementId, [])) {
      return false;
    }

    // Process remaining tokens from right to left
    var ancestorIndex = 0;
    for (var i = tokens.length - 2; i >= 0; i--) {
      var token = tokens[i];
      var combinator = tokens[i + 1].combinator; // Combinator that connects to next token
      var found = false;

      if (combinator === '>') {
        // Child combinator: must match immediate parent
        if (ancestorIndex < ancestors.length) {
          var parent = ancestors[ancestorIndex];
          var parentClassNames = parent.classes.join(' ');
          if (selectorMatches(token.selector, null, parentClassNames, parent.tag, parent.id, [])) {
            found = true;
            ancestorIndex++;
          }
        }
      } else if (combinator === '+' || combinator === '~') {
        // Sibling selectors: not fully supported in this context (need sibling info)
        // For now, treat as descendant (partial support)
        while (ancestorIndex < ancestors.length) {
          var ancestor = ancestors[ancestorIndex];
          var ancestorClassNames = ancestor.classes.join(' ');
          if (selectorMatches(token.selector, null, ancestorClassNames, ancestor.tag, ancestor.id, [])) {
            found = true;
            ancestorIndex++;
            break;
          }
          ancestorIndex++;
        }
      } else {
        // Descendant combinator (space): can skip ancestors
        while (ancestorIndex < ancestors.length) {
          var ancestor = ancestors[ancestorIndex];
          var ancestorClassNames = ancestor.classes.join(' ');
          if (selectorMatches(token.selector, null, ancestorClassNames, ancestor.tag, ancestor.id, [])) {
            found = true;
            ancestorIndex++;
            break;
          }
          ancestorIndex++;
        }
      }

      if (!found) {
        return false;
      }
    }

    return true;
  }

  // Parse selector into tokens with combinators
  function parseSelector(selector) {
    var tokens = [];
    var current = '';
    var lastCombinator = ' ';

    for (var i = 0; i < selector.length; i++) {
      var char = selector[i];

      if (char === '>' || char === '+' || char === '~') {
        if (current.trim()) {
          tokens.push({ selector: current.trim(), combinator: lastCombinator });
        }
        lastCombinator = char;
        current = '';
      } else if (char === ' ') {
        // Check if this is a space combinator or just whitespace around other combinators
        if (current.trim() && i + 1 < selector.length) {
          var nextNonSpace = selector.substring(i + 1).trimStart()[0];
          if (nextNonSpace !== '>' && nextNonSpace !== '+' && nextNonSpace !== '~') {
            tokens.push({ selector: current.trim(), combinator: lastCombinator });
            lastCombinator = ' ';
            current = '';
          }
        }
      } else {
        current += char;
      }
    }

    if (current.trim()) {
      tokens.push({ selector: current.trim(), combinator: lastCombinator });
    }

    return tokens;
  }

  // Funci√≥n para manejar clases combinadas (.class1.class2)
  function matchesCombinedClasses(selector, className) {
    if (!className) return false;

    var requiredClasses = selector.split('.').filter(function(c) { return c.trim(); });
    var elementClasses = className.split(' ').filter(function(c) { return c.trim(); });

    return requiredClasses.every(function(reqClass) {
      return elementClasses.indexOf(reqClass) !== -1;
    });
  }

  // Calcular especificidad CSS b√°sica
  function calculateSpecificity(selector) {
    var specificity = 0;

    // IDs = 100 (contar #)
    for (var si = 0; si < selector.length; si++) {
      if (selector[si] === '#') specificity += 100;
    }

    // Classes = 10 (contar .)
    for (var si = 0; si < selector.length; si++) {
      if (selector[si] === '.') specificity += 10;
    }

    // Elements = 1 (buscar palabras alfab√©ticas que no sigan a . o #)
    var inWord = false;
    var wordStart = 0;
    for (var si = 0; si <= selector.length; si++) {
      var ch = selector[si];
      var isAlpha = ch && ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch === '-');
      if (isAlpha && !inWord) {
        inWord = true;
        wordStart = si;
      } else if (!isAlpha && inWord) {
        inWord = false;
        // Verificar si la palabra anterior no empieza con . o #
        var prevChar = wordStart > 0 ? selector[wordStart - 1] : '';
        if (prevChar !== '.' && prevChar !== '#') {
          specificity += 1;
        }
      }
    }

    return specificity;
  }

  function getElementStyles(element) {
    var styles = {};
    var cssImportantStyles = {}; // CSS rules with !important

    // Obtener todos los selectores que coinciden y aplicar en orden de especificidad
    var matchingSelectors = getAllMatchingSelectors(element);

    for (var i = 0; i < matchingSelectors.length; i++) {
      var selectorStyles = matchingSelectors[i].styles;
      // Separate !important CSS properties
      for (var prop in selectorStyles) {
        if (selectorStyles.hasOwnProperty(prop)) {
          var val = selectorStyles[prop];
          if (typeof val === 'string' && val.indexOf('!important') !== -1) {
            cssImportantStyles[prop] = val.replace(/\s*!important\s*/gi, '').trim();
          } else {
            styles[prop] = val;
          }
        }
      }
    }

    // Apply inline styles (with !important tracking)
    var inlineStyle = element.getAttribute('style');
    var inlineNormal = {};
    var inlineImportant = {};

    if (inlineStyle) {
      var parsed = parseInlineStyles(inlineStyle, true);
      inlineNormal = parsed.styles;
      inlineImportant = parsed.important;
    }

    // CSS cascade order:
    // 1. Normal CSS (already in styles)
    // 2. Normal inline styles (override CSS)
    styles = Object.assign(styles, inlineNormal);
    // 3. CSS !important (override inline normal)
    styles = Object.assign(styles, cssImportantStyles);
    // 4. Inline !important (override everything)
    styles = Object.assign(styles, inlineImportant);

    return styles;
  }

  function nodeToStruct(node) {
    if (node.nodeType === 1) {
      var tag = node.tagName.toLowerCase();
      var styles = getElementStyles(node);
      var text = '';
      var children = [];
      var mixedContent = []; // NEW: Track order of text and elements

      // Extraer contenido de pseudoelementos
      var pseudoContent = extractPseudoContent(node, cssRules);

      // Add ::before content as first mixed content item
      if (pseudoContent.before) {
        mixedContent.push({ type: 'text', text: pseudoContent.before });
      }

      for (var i = 0; i < node.childNodes.length; i++) {
        var child = node.childNodes[i];
        if (child.nodeType === 3) {
          var textContent = child.textContent.trim();
          if (textContent) {
            text += textContent;
            // NEW: Add text to mixedContent array in order
            mixedContent.push({ type: 'text', text: textContent });
          }
        } else if (child.nodeType === 1) {
          var childStruct = nodeToStruct(child);
          if (childStruct) {
            children.push(childStruct);
            // NEW: Add element to mixedContent array in order
            mixedContent.push({ type: 'element', node: childStruct });
          }
        }
      }

      // Add ::after content as last mixed content item
      if (pseudoContent.after) {
        mixedContent.push({ type: 'text', text: pseudoContent.after });
      }

      // Legacy text property (for backward compatibility)
      if (pseudoContent.before) {
        text = pseudoContent.before + (text ? ' ' + text : '');
      }
      if (pseudoContent.after) {
        text = (text || '') + (text ? ' ' : '') + pseudoContent.after;
      }

      // Determine if this element has mixed content (text interleaved with elements)
      var hasMixedContent = false;
      var hasText = false;
      var hasElements = false;
      for (var j = 0; j < mixedContent.length; j++) {
        if (mixedContent[j].type === 'text') hasText = true;
        if (mixedContent[j].type === 'element') hasElements = true;
      }
      hasMixedContent = hasText && hasElements;

      return {
        type: 'element',
        tagName: tag,
        text: text.trim(),
        styles: styles,
        attributes: {
          value: node.getAttribute('value'),
          placeholder: node.getAttribute('placeholder'),
          alt: node.getAttribute('alt'),
          rows: node.getAttribute('rows')
        },
        children: children,
        mixedContent: hasMixedContent ? mixedContent : null, // Only include if truly mixed
        pseudoContent: pseudoContent // Guardar para referencia
      };
    }
    return null;
  }

  // Include body element with its styles (background, font-family, etc.)
  var bodyStruct = nodeToStruct(body);
  if (bodyStruct) {
    return [bodyStruct];
  }

  // Fallback: if body parsing fails, return children directly
  var result = [];
  for (var i = 0; i < body.childNodes.length; i++) {
    var child = nodeToStruct(body.childNodes[i]);
    if (child) result.push(child);
  }

  return result;
}

// Convert to Figma button functionality
document.getElementById('send-btn').onclick = function() {
  var htmlValue = document.getElementById('html-input').value;
  if (!htmlValue.trim()) {
    alert('Please paste some HTML code first.');
    return;
  }

  var structure = simpleParseHTML(htmlValue);
  var detectedWidth = detectDesignWidthFromHTML(htmlValue);
  var detectedRemBase = detectRootFontSize(htmlValue);

  parent.postMessage({
    pluginMessage: {
      type: 'html-structure',
      structure: structure,
      detectedWidth: detectedWidth,
      detectedRemBase: detectedRemBase
    }
  }, '*');
};

// Test Connection button functionality - REMOVED (now handled by addEventListener above)
// The test button is now 'test-broadcast-btn' and handled in the event listeners section

// Helper functions for new status system
function updateConnectionDetails(text) {
  var details = document.getElementById('connection-details');
  if (details) {
    details.textContent = text;
  }
}

function updateMCPStatus(text, status) {
  var indicator = document.getElementById('mcp-indicator');
  var statusText = document.getElementById('mcp-status-text');

  if (statusText) {
    statusText.textContent = text;
  }

  if (indicator) {
    indicator.className = 'status-icon';
    switch(status) {
      case 'success':
      case 'connected':
        indicator.classList.add('connected');
        break;
      case 'waiting':
      case 'info':
      case 'connecting':
        indicator.classList.add('warning');
        break;
      case 'error':
        indicator.classList.add('error');
        break;
      default:
        indicator.classList.add('inactive');
    }
  }
    }

// Status message function - DEPRECATED - now using direct status functions
function updateStatusMessage(message, type) {
  // Legacy function - redirected to new system
  updateConnectionDetails(message);
  if (message.includes('MCP') || message.includes('connection') || message.includes('test')) {
    updateMCPStatus(message, type);
  }
}

// Listen for messages from the plugin
window.addEventListener('message', function(event) {
  if (event.data.pluginMessage) {
    var msg = event.data.pluginMessage;

    if (msg.type === 'mcp-test-response') {
      updateStatusMessage(msg.message, 'info');
    } else if (msg.type === 'mcp-status-update') {
      updateStatusMessage(msg.message, msg.status || 'info');
    } else if (msg.type === 'parse-mcp-html') {
      updateStatusMessage('Processing: ' + msg.name, 'waiting');

      try {
        var structure = simpleParseHTML(msg.html);
        parent.postMessage({
          pluginMessage: {
            type: 'html-structure',
            structure: structure,
            name: msg.name,
            fromMCP: true
          }
        }, '*');

        updateStatusMessage('Converted: ' + msg.name, 'success');
      } catch (error) {
        updateStatusMessage('Error processing HTML', 'error');
      }
    } else if (msg.type === 'request-file-mcp-data') {
      // Handle file system reading for MCP data
      fetch('./mcp-shared-data.json')
        .then(response => response.ok ? response.json() : Promise.reject('Not found'))
        .then(data => {
          parent.postMessage({
            pluginMessage: {
              type: 'file-mcp-data-response',
              data: data
            }
          }, '*');
        })
        .catch(error => {
          parent.postMessage({
            pluginMessage: {
              type: 'file-mcp-data-response',
              data: null
            }
          }, '*');
        });
    } else if (msg.type === 'delete-file-mcp-data') {
      // Handle cleanup request
      fetch('./mcp-shared-data.json', { method: 'DELETE' })
        .then(() => console.log('MCP file cleanup completed'))
        .catch(() => console.log('MCP file cleanup attempted'));
    }
  }
});

// ===============================================
// SSE FUNCTIONALITY - Real Implementation
// ===============================================

var eventSource = null;
var sseConnected = false;
var sseReconnectAttempts = 0;
var maxReconnectAttempts = 5;
var sseReconnectDelay = 3000;

function startRealSSEConnection() {
  debugLog('[SSE] Starting real SSE connection...');

  if (eventSource) {
    eventSource.close();
  }

  // Check if we have a session ID
  if (!currentSessionId) {
    debugLog('[SSE] Warning: No session ID available yet, waiting...');
    updateSSEStatus('Waiting for Session ID', 'warning');
    // Retry after a short delay
    setTimeout(startRealSSEConnection, 500);
    return;
  }

  // Detect server first, then connect
  detectServer(function() {
    connectToSSE();
  });
}

function connectToSSE() {
  try {
    // Include session ID in the SSE connection URL
    var sseUrl = MCP_SERVER_URL + '/mcp-stream?sessionId=' + encodeURIComponent(currentSessionId);
    debugLog('[SSE] Connecting to:', sseUrl);
    eventSource = new EventSource(sseUrl);

    eventSource.onopen = function(event) {
      debugLog('[SSE] Connection opened successfully');
      sseConnected = true;
      sseReconnectAttempts = 0;
      updateSSEStatus('SSE Connected', 'connected');
      updateConnectionStatus('connected');
      updateConnectionDetails('Connected as: ' + currentSessionId);
    };

    eventSource.onmessage = function(event) {
      debugLog('[SSE] Message received:', event.data);

      try {
        var data = JSON.parse(event.data);
        processSSEMessage(data);
      } catch (error) {
        console.error('[SSE] Error parsing message:', error);
      }
    };

    eventSource.onerror = function(event) {
      console.error('[SSE] Connection error:', event);
      sseConnected = false;

      if (eventSource.readyState === EventSource.CLOSED) {
        updateSSEStatus('SSE Disconnected', 'error');
        updateConnectionStatus('error');
        updateConnectionDetails('Connection lost');
        attemptSSEReconnection();
      } else {
        updateSSEStatus('SSE Connection Issues', 'warning');
        updateConnectionStatus('warning');
        updateConnectionDetails('Connection unstable');
      }
    };

  } catch (error) {
    console.error('[SSE] Failed to create EventSource:', error);
    updateSSEStatus('SSE Failed to Start', 'error');
    updateConnectionStatus('error');
    updateConnectionDetails('Failed to start SSE');
  }
}

function stopRealSSEConnection() {
  debugLog('[SSE] Stopping real SSE connection...');

  if (eventSource) {
    eventSource.close();
    eventSource = null;
  }

  sseConnected = false;
  sseReconnectAttempts = 0;
  updateSSEStatus('SSE Disconnected', 'disconnected');
  updateConnectionStatus('disconnected');
  updateConnectionDetails('Ready to connect');
}

function attemptSSEReconnection() {
  if (sseReconnectAttempts >= maxReconnectAttempts) {
    debugLog('[SSE] Max reconnection attempts reached');
    updateSSEStatus('SSE Connection Failed', 'error');
    updateConnectionStatus('error');
    updateConnectionDetails('Max reconnection attempts reached');
    return;
  }

  sseReconnectAttempts++;
  updateSSEStatus('Reconnecting (' + sseReconnectAttempts + '/' + maxReconnectAttempts + ')', 'connecting');
  updateConnectionStatus('warning');
  updateConnectionDetails('Reconnecting...');

  setTimeout(function() {
    debugLog('[SSE] Reconnection attempt ' + sseReconnectAttempts);
    startRealSSEConnection();
  }, sseReconnectDelay);
}

function processSSEMessage(data) {
  debugLog('[SSE] Processing message:', data);

  switch (data.type) {
    case 'connection-established':
      debugLog('[SSE] Connection established confirmed');
      updateSSEStatus('SSE Ready', 'connected');
      updateMCPStatus('MCP Ready', 'connected');
      updateConnectionDetails('Ready for MCP requests');
      break;

    case 'mcp-request':
      debugLog('[SSE] MCP request received:', data);
      handleSSEMCPRequest(data);
      break;

    case 'test-message':
      debugLog('[SSE] Test message received:', data.message);
      updateConnectionDetails('Test: ' + data.message);
      break;

    case 'heartbeat':
      debugLog('[SSE] Heartbeat received');
      // Heartbeat messages keep the connection alive, no action needed
      break;

    default:
      debugLog('[SSE] Unknown message type:', data.type);
  }
}

function handleSSEMCPRequest(data) {
  if (data.function === 'mcp_html_to_design_import-html') {
    var htmlContent = data.arguments.html;
    var designName = data.arguments.name || 'SSE Import';

    debugLog('[SSE] Processing HTML import:', designName);
    debugLog('[SSE] *** USING DIRECT PARSING - TYPESCRIPT VERSION 4.0 ***');
    updateConnectionDetails('Processing: ' + designName);
    updateMCPStatus('Processing: ' + designName, 'connecting');

    // DIRECT PROCESSING: Parse HTML and send structure directly
    try {
      debugLog('[SSE] Calling simpleParseHTML directly...');
      var structure = simpleParseHTML(htmlContent);
      debugLog('[SSE] HTML parsed, structure length:', structure?.length || 0);

      // Detect design width from meta tags and CSS
      var detectedWidth = detectDesignWidthFromHTML(htmlContent);
      var detectedRemBase = detectRootFontSize(htmlContent);
      debugLog('[SSE] Detected design width:', detectedWidth, 'rem base:', detectedRemBase);

      // Send html-structure directly to main handler (skip parse-mcp-html)
      parent.postMessage({
        pluginMessage: {
          type: 'html-structure',
          structure: structure,
          name: designName,
          fromMCP: true,
          mcpSource: 'sse',
          requestId: data.requestId,
          timestamp: data.timestamp,
          detectedWidth: detectedWidth,
          detectedRemBase: detectedRemBase
        }
      }, '*');

      debugLog('[SSE] Sent html-structure directly to main handler');
      updateMCPStatus('Converted: ' + designName, 'success');

    } catch (error) {
      console.error('[SSE] Error parsing HTML:', error);
      updateMCPStatus('Error: ' + error.message, 'error');
    }

  } else {
    debugLog('[SSE] Unknown MCP function:', data.function);
    updateConnectionDetails('Unknown function: ' + data.function);
  }
}

// Enhanced message handling for SSE
window.addEventListener('message', function(event) {
  if (event.data.pluginMessage) {
    var msg = event.data.pluginMessage;

    // Handle session ID from plugin
    if (msg.type === 'session-id') {
      currentSessionId = msg.sessionId;
      updateConfigDisplay(); // Update the MCP config with the new session ID
      debugLog('[Session] Received session ID:', msg.sessionId);
    }

    // Handle SSE control messages
    if (msg.type === 'start-sse-connection') {
      startRealSSEConnection();
    } else if (msg.type === 'stop-sse-connection') {
      stopRealSSEConnection();
    } else if (msg.type === 'sse-connected') {
      updateSSEStatus('SSE Connected', 'connected');
      updateMCPStatus('MCP Ready', 'connected');
    } else if (msg.type === 'sse-disconnected') {
      updateSSEStatus('SSE Disconnected', 'disconnected');
      updateMCPStatus('MCP Inactive', 'disconnected');
    } else if (msg.type === 'test-broadcast-complete') {
      updateConnectionDetails('Connection test completed');
    }
  }
});

</script>
</body>
</html>